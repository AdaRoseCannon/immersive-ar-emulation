{"version":3,"file":"EmulateAR.aframe.js","sources":["../src/EmulateAR.js","../src/EmulateAR.aframe.js"],"sourcesContent":["const isSessionSupportedOld = navigator.xr.isSessionSupported.bind(navigator.xr);\nconst requestSessionOld = navigator.xr.requestSession.bind(navigator.xr);\nconst sceneModelURL = 'https://ada.is/immersive-ar-emulation/assets/room.glb';\nlet inSession = false;\nlet environmentModel;\nlet referenceSpace;\nlet renderFunc = function () { };\n\nasync function requestHitTestSource(options) {\n\tconst session = this;\n\treturn new HitTestSource(session, options);\n}\n\nasync function requestHitTestSourceForTransientInput(options) {\n\tconst session = this;\n\treturn new TransientHitTestSource(session, options);\n}\n\nclass HitTestSource {\n\tconstructor(session, {\n\t\tspace,\n\t\toffsetRay\n\t}) {\n\t\tthis.__space = space;\n\t\tthis.__offsetRay = offsetRay;\n\t\tthis.__session = session;\n\t}\n\n\tcancel() {\n\t\tthis.__space = null;\n\t\tthis.__offsetRay = null;\n\t\tthis.__session = null;\n\t\tthis.__canceled = true;\n\t}\n}\n\n// eslint-disable-next-line no-unused-vars\nclass EmulatedXRPose {\n\tconstructor(transform) {\n\t\tthis.transform = transform;\n\t}\n}\n\nclass XRHitTestResult {\n\tconstructor(frame, position, orientation) {\n\t\tthis.__transform = new window.XRRigidTransform(position, orientation);\n\t\tthis.__frame = frame;\n\t}\n\n\tgetPose(refSpace) {\n\t\t// return new EmulatedXRPose(this.__transform);\n\t\tconst offsetReferenceSpace = referenceSpace.getOffsetReferenceSpace(this.__transform);\n\t\tconst pose = this.__frame.getPose(offsetReferenceSpace, refSpace);\n\t\treturn pose;\n\t}\n}\n\nclass TransientHitTestSource {\n\tconstructor(session, {\n\t\tspace,\n\t\toffsetRay\n\t}) {\n\t\tspace;\n\t\toffsetRay;\n\n\t\t// Do nothing this is not supported for headsets\n\t}\n\n\tcancel() {\n\t\t\n\t}\n}\n\t\nfunction getHitTestResultsForTransientInput() {\n\treturn [];\n}\n\nfunction setReferenceSpace(refSpace) {\n\treferenceSpace = refSpace;\n}\n\nfunction onSessionEnded() {\n\tinSession = false;\n}\nfunction onSessionStart() {\n\tinSession = true;\n}\n\nfunction renderEnvironment(camera) {\n\trenderFunc(camera);\n}\n\nasync function immersiveARProxyRequired() {\n\t// If there is no WebXR support then do nothing, probably on http\n\tif (!navigator.xr) return false;\n\n\t// if AR is already supported we don't need to do anything\n\tif (await navigator.xr.isSessionSupported('immersive-ar')) return false;\n\n\t// if immersive-vr isn't supported then we can't do anything\n\tif (! await navigator.xr.isSessionSupported('immersive-vr')) return false;\n\n\treturn true;\n}\n\nasync function applyImmersiveARProxy() {\n\tif (! await immersiveARProxyRequired()) return console.log('AR Proxy not applied,because either immersive-ar is already supported or immersive-vr is not supported.');\n\n\tnavigator.xr.requestSession = requestSession.bind(navigator.xr);\n\tnavigator.xr.isSessionSupported = isSessionSupported.bind(navigator.xr);\n}\n\t\nfunction isSessionSupported(type) {\n\tconsole.log('Proxied isSessionSupported');\n\n\tif (type === 'immersive-ar') {\n\t\treturn isSessionSupportedOld('immersive-vr');\n\t}\n\treturn isSessionSupportedOld(type);\n}\n\nlet getHitTestResults = function () { };\n\nasync function requestSession(type, sessionInit) {\n\tconsole.log('Proxied requestSession');\n\n\tif (type === 'immersive-ar') {\n\t\ttype = 'immersive-vr';\n\t} else {\n\t\treturn requestSessionOld(type, sessionInit);\n\t}\n\n\tconst featuresToPolyfill = [];\n\tsessionInit.optionalFeatures = sessionInit.optionalFeatures.filter(function (name) {\n\t\tswitch (name) {\n\t\t\tcase 'hit-test':\n\t\t\tcase 'lighting-estimation':\n\t\t\t\tfeaturesToPolyfill.push(name);\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t});\n\n\tconst session = await requestSessionOld(type, sessionInit);\n\n\tonSessionStart();\n\tsession.addEventListener( 'end', onSessionEnded );\n\n\tObject.defineProperty(session, 'requestHitTestSource', {\n\t\tvalue: requestHitTestSource,\n\t\tconfigurable: true\n\t});\n\n\tObject.defineProperty(session, 'requestHitTestSourceForTransientInput', {\n\t\tvalue: requestHitTestSourceForTransientInput,\n\t\tconfigurable: true\n\t});\n\n\tconst requestAnimationFrameOld = session.requestAnimationFrame.bind(session);\n\tObject.defineProperty(session, 'requestAnimationFrame', {\n\t\tvalue: function (animationFrameCallback) {\n\t\t\trequestAnimationFrameOld(function (time, xrFrame) {\n\n\t\t\t\tObject.defineProperty(xrFrame, 'getHitTestResultsForTransientInput', {\n\t\t\t\t\tvalue: getHitTestResultsForTransientInput.bind(xrFrame),\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\n\t\t\t\tObject.defineProperty(xrFrame, 'getHitTestResults', {\n\t\t\t\t\tvalue: getHitTestResults.bind(xrFrame),\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tanimationFrameCallback(time, xrFrame);\n\t\t\t})\n\t\t},\n\t\tconfigurable: true\n\t});\n\n\treturn session;\n}\n\nfunction init({ renderer, scene, environment }) {\n\n\tconst bgscene = scene.clone(false);\n\trenderFunc = function renderEnvironment(camera) {\n\t\n\t\tif (!inSession) return;\n\t\trenderer.clear();\n\t\trenderer.render(bgscene, camera);\n\t\trenderer.clearDepth();\n\t}\n\n\trenderer.autoClear = false;\n\t\n\trenderer.xr.addEventListener('sessionstart', function () {\n\n\t\tsetReferenceSpace(renderer.xr.getReferenceSpace());\n\n\t});\n\t\n\t// Ensure normal vectors are available\n\tenvironment.traverse(o => {\n\t\tif (o.geometry && o.material) {\n\t\t\to.geometry.computeFaceNormals();\n\t\t}\n\t});\n\n\tbgscene.add(environment);\n\n\tenvironmentModel = environment;\n\n\tconst tempQuaternion = new THREE.Quaternion();\n\tconst tempQuaternion2 = new THREE.Quaternion();\n\tconst tempVec = new THREE.Vector3();\n\tconst directionProjectedOntoPlane = new THREE.Vector3();\n\tfunction normalToOrientation(normal, direction) {\n\t\tnormal.normalize();\n\t\tdirection.normalize();\n\t\n\t\ttempVec.set(0, 1, 0);\n\t\n\t\t// Find out what the angle should be from the direction vector\n\t\ttempQuaternion.setFromUnitVectors(tempVec, normal);\n\t\n\t\tconst normalSquared = normal.lengthSq();\n\t\tconst vectorDotNormal = direction.dot(normal);\n\t\n\t\t// get the direction projected onto the plane\n\t\tdirectionProjectedOntoPlane.copy(normal).multiplyScalar(-1 * vectorDotNormal / normalSquared).add(direction);\n\t\n\t\t// Get the -z unit vector in the plane\n\t\ttempVec.set(0, 0, -1);\n\t\ttempVec.applyQuaternion(tempQuaternion);\n\t\n\t\t// calculate the angle between them\n\t\ttempQuaternion2.setFromUnitVectors(tempVec, directionProjectedOntoPlane);\n\t\n\t\ttempQuaternion.premultiply(tempQuaternion2);\n\t\n\t\treturn tempQuaternion.clone();\n\t}\n\n\tconst direction = new THREE.Vector3();\n\tconst raycaster = new THREE.Raycaster();\n\tgetHitTestResults = function getHitTestResults(hitTestSource) {\n\t\n\t\tif (!environmentModel) return [];\n\t\n\t\tconst frame = this;\n\t\tconst space = hitTestSource.__offsetRay ? hitTestSource.__space.getOffsetReferenceSpace(hitTestSource.__offsetRay) : hitTestSource.__space;\n\t\n\t\tconst pose = frame.getPose(space, referenceSpace);\n\t\n\t\tif (pose === null) return [];\n\t\n\t\tdirection.set(0, 0, -1);\n\t\tdirection.applyQuaternion(pose.transform.orientation)\n\t\traycaster.set(pose.transform.position, direction);\n\t\treturn raycaster.intersectObject(environmentModel, true)\n\t\t\t.map(result => new XRHitTestResult(\n\t\t\t\tframe,\n\t\t\t\tresult.point,\n\t\t\t\tnormalToOrientation(result.face.normal, direction)\n\t\t\t))\n\t}\n}\n\nexport {\n\tinit,\n\tsceneModelURL,\n\trequestSession, // async\n\trenderEnvironment,\n\tisSessionSupported, // async\n\tapplyImmersiveARProxy, //async\n\timmersiveARProxyRequired, //async\n}","/* global AFRAME, THREE */\n\nimport {\n\tinit as initEmulateAR,\n\t// eslint-disable-next-line no-unused-vars\n\trequestSession,\n\t// eslint-disable-next-line no-unused-vars\n\tisSessionSupported,\n\trenderEnvironment,\n\tapplyImmersiveARProxy,\n\tsceneModelURL,\n} from \"./EmulateAR.js\";\n\napplyImmersiveARProxy();\n\nwindow.addEventListener('DOMContentLoaded', function () {\n\n\tconst loader = new THREE.GLTFLoader();\n\tfunction loadModel(url) {\n\t\t\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tloader.load(\n\t\t\t\turl,\n\t\t\t\tfunction (gltf) {\n\t\t\t\t\tresolve(gltf);\n\t\t\t\t},\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\tfunction ( xhr ) {},\n\t\t\t\tfunction ( error ) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t);\n\t\t})\n\t}\n\t\n\tAFRAME.registerSystem(\"my-component\", {\n\t\tschema: {}, \n\t\n\t\tinit: function () {\n\t\t\tconst renderer = this.el.renderer;\n\t\t\tconst scene = this.el.object3D;\n\t\t\tconst environment = new THREE.Object3D();\n\t\n\t\t\tloadModel(sceneModelURL)\n\t\t\t\t.then(({ scene }) => environment.add(scene));\n\t\t\tinitEmulateAR({ scene, renderer, environment });\n\t\t},\n\t\ttick() {\n\t\t\trenderEnvironment(this.el.camera);\n\t\t}\n\t});\n\t\n});"],"names":["isSessionSupportedOld","navigator","xr","isSessionSupported","bind","requestSessionOld","requestSession","environmentModel","referenceSpace","inSession","renderFunc","async","requestHitTestSource","options","HitTestSource","this","requestHitTestSourceForTransientInput","TransientHitTestSource","[object Object]","session","space","offsetRay","__space","__offsetRay","__session","__canceled","XRHitTestResult","frame","position","orientation","__transform","window","XRRigidTransform","__frame","refSpace","offsetReferenceSpace","getOffsetReferenceSpace","getPose","getHitTestResultsForTransientInput","onSessionEnded","type","console","log","getHitTestResults","sessionInit","optionalFeatures","filter","name","addEventListener","Object","defineProperty","value","configurable","requestAnimationFrameOld","requestAnimationFrame","animationFrameCallback","time","xrFrame","init","renderer","scene","environment","bgscene","clone","camera","clear","render","clearDepth","autoClear","getReferenceSpace","traverse","o","geometry","material","computeFaceNormals","add","tempQuaternion","THREE","Quaternion","tempQuaternion2","tempVec","Vector3","directionProjectedOntoPlane","direction","raycaster","Raycaster","hitTestSource","pose","set","applyQuaternion","transform","intersectObject","map","result","point","normal","normalize","setFromUnitVectors","normalSquared","lengthSq","vectorDotNormal","dot","copy","multiplyScalar","premultiply","normalToOrientation","face","immersiveARProxyRequired","applyImmersiveARProxy","loader","GLTFLoader","AFRAME","registerSystem","schema","el","object3D","Object3D","url","Promise","resolve","reject","load","gltf","xhr","error","then","initEmulateAR"],"mappings":"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"}